head	1.16;
access;
symbols;
locks; strict;
comment	@# @;


1.16
date	99.09.22.03.16.48;	author guido;	state Exp;
branches;
next	1.15;

1.15
date	99.09.07.23.19.53;	author guido;	state Exp;
branches;
next	1.14;

1.14
date	99.09.05.00.38.21;	author guido;	state Exp;
branches;
next	1.13;

1.13
date	99.09.04.20.51.43;	author guido;	state Exp;
branches;
next	1.12;

1.12
date	99.08.29.00.42.46;	author guido;	state Exp;
branches;
next	1.11;

1.11
date	99.08.28.01.54.35;	author guido;	state Exp;
branches;
next	1.10;

1.10
date	99.08.22.21.55.22;	author guido;	state Exp;
branches;
next	1.9;

1.9
date	99.08.22.00.38.13;	author guido;	state Exp;
branches;
next	1.8;

1.8
date	99.08.19.17.57.20;	author guido;	state Exp;
branches;
next	1.7;

1.7
date	99.08.18.23.49.46;	author root;	state Exp;
branches;
next	1.6;

1.6
date	99.08.18.19.58.34;	author guido;	state Exp;
branches;
next	1.5;

1.5
date	99.08.14.13.59.24;	author guido;	state Exp;
branches;
next	1.4;

1.4
date	99.08.13.14.31.49;	author guido;	state Exp;
branches;
next	1.3;

1.3
date	99.08.11.20.54.24;	author guido;	state Exp;
branches;
next	1.2;

1.2
date	99.08.11.11.40.01;	author guido;	state Exp;
branches;
next	1.1;

1.1
date	99.08.10.23.40.23;	author guido;	state Exp;
branches;
next	;


desc
@Generate as much as possible of the Sparemint site.
@


1.16
log
@Fixed wrong HREF in group list (thanks to Frank Naumann for finding
the bug).
@
text
@#! /usr/bin/perl
# buildsite.pl - Rebuild html versions of Sparemint files.
# Copyright (C) 1999 Guido Flohr <gufl0000@@stud.uni-sb.de>.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
# USA.  */

# $Id: buildsite.pl,v 1.15 1999/09/07 23:19:53 guido Exp guido $

# TODO/FIXME/BUGS:
# - Use mktemp/rename when rewriting files to avoid race conditions
#   while being mirrored.
# - Why can't we sum up the number of packages and the sizes in
#   the group list?
# - Design a resource description format schema and embed RDF in
#   the html files (see http://www.w3.org/TR/).

##########################################################################
# Configuration stuff, change these variables to your needs.
##########################################################################
$rpm = "rpm";        # Default: in $PATH.

##########################################################################
# Version control.
##########################################################################
$Revision = '$Revision: 1.15 $';
$Version;

##########################################################################
# External modules used.
##########################################################################
use File::Basename;
use File::stat;
use POSIX;
use IO::Handle;
use Getopt::Long;

##########################################################################
# Global variables.
##########################################################################
# Directories.
$base_dir;
$sparemint_dir;
$rpms_dir;
$rpms_m68kmint_dir;
$rpms_noarch_dir;
$srpms_dir;
$sitebin_dir;
$html_dir;
$pkg_dir;
$images_dir;
$misc_dir;
$ntw_dir;
$ntm_dir;
$expired_dir;

$prog_name;
$verbose = 0;
$now = time;
$one_week = 7 * 24 * 60 * 60;
$one_month = 30 * 24 * 60 * 60;  # Accurate enough.

# File names.
$package_list;
$authors_list;

##########################################################################
# File fragments.
##########################################################################
$packages_header = "# This file contains a list of packages that are already available for
# Sparemint or are planned to be made available in the future.
# Format is as follows: 
#
# 	Package|Status|Maintainer|New Maintainer
#
# See the file \`AUTHORS' in the same directory for the meaning of
# the short tags in the \`Maintainer' column.
#
# The \`Status' is one of the following:
#
#	a - assigned
#	    The package is already assigned to a new maintainer but
#	    not yet ready.
#	o - orphaned
#	    The package is ready but currently orphaned.  If you
#           are interested in taking over the maintainance please
#           contact the Sparemint people.
#       r - released
#           The current maintainer has a released version ready
#           for download.
#	w - waiting
#	    There is no binary package available.
#
# An empty status is equivalent to status \`waiting'.

";

$authors_header = "# This file is a list of the people that are currently maintaining
# Sparemint packages.  Format is as follows:
#
# 	Tag|Full Name|E-Mail|Homepage

";

# Global hashs.
%srpms;
%rpms;
%authors;
%packages;
%ntw_links;
%ntm_links;
%htmls;

# Subroutines.
sub setup;
sub find_me;
sub read_authors;
sub read_all_srpms;
sub read_all_rpms;
sub read_rpms;
sub expire_rpms;
sub read_delete_list;
sub delete_stale;
sub canonicalize_address;
sub read_packages;
sub write_ftp_files;
sub format_number;
sub write_authors_html;
sub write_group_packages;
sub write_alpha_packages;
sub write_todos;
sub by_group;

# Main program.
setup;
find_me;
read_delete_list;
read_authors;
read_packages;
read_all_srpms;
read_all_rpms;
expire_rpms;
write_ftp_files;
write_authors_html;
write_alpha_packages;
write_alpha_packages "ntw";
write_alpha_packages "ntm";
write_group_packages;
write_todos;
delete_stale;

sub setup {
  STDERR->autoflush (1);
  STDOUT->autoflush (1);
  
  $Version = $Revision;
  $Version =~ s,.*Revision: ,,g;
  $Version =~ s, .,,g;
  
  # NLS nuisances.  Avoid spurious non-English strings in output.
  POSIX::setlocale (&POSIX::LC_ALL, "POSIX");
  $ENV{'LANG'} = $ENV{'LANGUAGE'} = $ENV{'LC_ALL'} = "POSIX";
 
  GetOptions ("--verbose" => $opt_verbose,
	      "-v" =>        $opt_verbose, 
              "--help" =>    $opt_help,
	      "-h" =>        $opt_help,
              "--version" => $opt_version,
	      "-V" =>        $opt_version) 
      or die "Try `$0 --help' for more information";

  if ($opt_help) {
    print <<EOF;
Usage: $0 [ OPTIONS ]
Consistency check the Sparemint files and build the html pages. Options:

  --help, -h               Display this help page and exit
  --verbose, -v            Print diagnostic output on stdout.
  --version, -V            Print version information and exit

Report bugs to Guido Flohr <gufl0000\@@stud.uni-sb.de>.
EOF

    exit 0;
  }

  if ($opt_version) {
    print <<EOF;
$0 (Sparemint) Revision $Version
Copyright (C) 1999 Guido Flohr (gufl0000\@@stud.uni-sb.de)
This program is free software; you may redistribute it under the terms of
the GNU General Public License.  This program has absolutely no warranty.
EOF
    exit 0;
  }
  
  if ($opt_verbose) {
    $verbose = 1;
  }
}

# Find ourselves so that we have a well-known directory structure.
sub find_me {
  my $program_invocation_name = $0;
  $prog_name = basename $program_invocation_name;
  my $here;
  
  if ($prog_name eq $program_invocation_name) {
    $here = "./";
  } else {
    my $l1 = length ($prog_name);
    my $l2 = length ($program_invocation_name);
    $here = substr $program_invocation_name, 0, $l2 - $l1;
  }
  
  # Now cd into that directory and construct the directory names.
  chdir $here . "/../..";
  $base_dir = `pwd`;
  chomp $base_dir;
  $sparemint_dir = $base_dir . "/sparemint";
  $rpms_dir = $sparemint_dir . "/RPMS";
  $rpms_m68kmint_dir = $rpms_dir . "/m68kmint";
  $rpms_noarch_dir = $rpms_dir . "/noarch";
  $srpms_dir = $sparemint_dir . "/SRPMS";
  $sitebin_dir = $sparemint_dir . "/sitebin";
  $html_dir = $sparemint_dir . "/html";
  $pkg_dir = $html_dir . "/packages";
  $images_dir = $html_dir . "/images";
  $misc_dir = $sparemint_dir . "/misc";
  $ntw_dir = $sparemint_dir . "/NEW-THIS-WEEK";
  $ntm_dir = $sparemint_dir . "/NEW-THIS-MONTH";
  $expired_dir = $sparemint_dir . "/expired";
  
  $package_list = $sitebin_dir . "/PACKAGES.in";
  $authors_list = $sitebin_dir . "/AUTHORS.in";

  # Check if all directories exist and have the correct permissions.
  my $errors = "no";
  my %permissions = (
    #$base_dir => 0755,
    $sparemint_dir => 0755,
    $rpms_dir => 0755,
    $rpms_m68kmint_dir => 0755,
    $rpms_noarch_dir => 0755,
    $srpms_dir => 0755,
    $sitebin_dir => 0755,
    $html_dir => 0755,
    $pkg_dir => 0755,
    $images_dir => 0755,
    $misc_dir => 0755,
    $ntw_dir => 0755,
    $ntm_dir => 0755,
    $expired_dir => 0755,
  );
  
  foreach my $dir (keys %permissions) {
    print "checking for $dir ...\n" if $verbose;
    
    if (my $st = stat ($dir)) {
      # Check if it is a directory.
      if (S_ISDIR ($st->mode)) {
        if (($st->mode & 0xfff) != $permissions{$dir}) {
          $errors = "yes";
          print STDERR "$prog_name: error: wrong permissions for directory $dir.\n";
          printf STDERR "(Please run \`chmod %o $dir' to fix that.)\n",
                        $permissions{$dir};
        }
      } else {
        $errors = "yes";
        print STDERR "$prog_name: error: $dir is not a directory.\n";
      }
    } else {
      $errors = "yes";
      print STDERR "$prog_name: error: directory $dir does not exist.\n";
    }
  }
  
  # Check if the files that we absolutely need exist.  If not create
  # them.
  %filelist = (
    $package_list => "$packages_header",
    $authors_list => "$authors_header",
  );  
  
  foreach my $file (keys %filelist) {
    print "checking for $file ...\n" if $verbose;
    my $contents = $filelist{$file};
    my $bits = 0644;

    if (my $st = stat ($file)) {
      # Check if it is a regular file.
      if (S_ISREG ($st->mode)) {
        if (($st->mode & 0xfff) != $bits) {
          $errors = "yes";
          print STDERR "$prog_name: error: wrong permissions for file $dir.\n";
          printf STDERR "(Please run \`chmod %o $file' to fix that.)\n",
                        $bits;
        }
      } else {
        $errors = "yes";
        print STDERR "$prog_name: error: $file is not a regular file.\n";
      }
    } else {
      # Create the file.
      open HANDLE, ">$file" or die "$prog_name: error: cannot create $file: $!";
      print HANDLE $contents;
      close HANDLE or die "$prog_name: error: cannot close $file: $!\n";
      print STDERR "$prog_name: created missing file $file\n";
    }
  }
  
  die "$prog_name: unrecoverable errors encountered" unless $errors eq "no";
}

# Read authors file.
sub read_authors {
  print "parsing $authors_list\n" if $verbose;
  open AUTHORS, $authors_list 
      or die "$prog_name: can't open $authors_list for reading: $!";
  
  AUTHOR: while (<AUTHORS>) {
    chomp;
    s,#.*$,,g;
    next AUTHOR if /^[ \t]*$/;
    my ($tag, $fullname, $email, $http) = split /\|/;
    $authors{$tag}{name} = $fullname;
    $authors{$tag}{email} = $email;
    $_ = $http;
    unless (/^\s$/) {
      $authors{$tag}{http} = $http;
    }
  }
  
  close AUTHORS;
}

# Read all source rpms.
sub read_all_srpms
{
  my $size;
  my $mtime;

  opendir DIR, $srpms_dir or die "$prog_name: can't opendir $srpms_dir: $!";
  my @@files = grep { ! /^\./ && -f "$srpms_dir/$_" } readdir(DIR);
  closedir DIR;
  
  SRPM: foreach my $file (@@files) {
    my $fullname = $srpms_dir . "/" . $file;
    print "querying $file ...\n" if $verbose;
    open RPM, "$rpm -qp --queryformat '%{name} %{version} %{release}' $fullname |"
      or die "$prog_name: error: rpm -qp $fullname failed";
    $query = <RPM>;
    my ($package, $version, $release) = split / /, $query;
    close RPM;
    my $rc = 0xffff & $?;
    
    if ($rc & 0xff00) {
      die "$prog_name: error: $rpm -qp $fullname failed: $!";
    } elsif ($rc > 0x80) {
      $rc >>= 8;
      print STDERR "$prog_name: warning: skipping $fullname\n";
      next SRPM;
    } elsif ($rc != 0) {
      print STDERR "$prog_name: warning: $rpm -qp $fullname: ";
      if ($rc & 0x80) {
        $rc &= ~0x80;
	print STDERR "core dump from ";
      } else {
        print STDERR "killed by ";
      }
      print STDERR "signal $rc\n";
      
      next SRPM;	
    }

    chmod 0444, $fullname or die "cannot chmod 0444 $fullname: $!";
      
    if ("$file" ne "$package" . "-$version" . "-$release.src.rpm") {
      print STDERR "$prog_name: warning: skipping $file\n";
      print STDERR "(Please rename $file to $package"
        . "-$version" . "-$release.src.rpm\n";
      next SRPM;
    }
    
    if (my $st = stat ($fullname)) {
      $size = $st->size;
      $mtime = $st->mtime;

      if ($now < $st->mtime + $one_week) {
        my $name = "$package-$version-$release.src.rpm";
	if ($ntw_links{$name} != 1) {
	    my $link = "../SRPMS/$name";
	    my $target = "$ntw_dir/$name";
	    symlink $link, $target
		or die "$prog_name: error: cannot symlink $link to $target: $!\n";
	    print "symlink $link to $target\n" if $verbose;
	} else {
	    delete $ntw_links{$name};
	}
      }
      if ($now < $st->mtime + $one_month) {
        my $name = "$package-$version-$release.src.rpm";
	if ($ntm_links{$name} != 1) {
	    my $link = "../SRPMS/$name";
	    my $target = "$ntm_dir/$name";
	    symlink $link, $target
		or die "$prog_name: error: cannot symlink $link to $target: $!\n";
	    print "symlink $link to $target\n" if $verbose;
	} else {
	    delete $ntm_links{$name};
	}
      }
    } else {
      die "$prog_name: error: cannot stat $fullname: $!\n";
    }
    
    # OK, the file is fine, save the information.
    $srpms{$file}{package} = $package;
    $srpms{$file}{version} = $version;
    $srpms{$file}{release} = $release;
    $srpms{$file}{size} = $size;
    $srpms{$file}{mtime} = $mtime;
  }
}

# Get a list of files to be deleted unless used.
sub read_delete_list
{
    print "reading links in $ntw_dir\n" if $verbose;
    opendir DIR, $ntw_dir or die "$prog_name: can't opendir $ntw_dir: $!";
    my @@files = grep { ! /^\./ && -f "$ntw_dir/$_" } readdir(DIR);
    closedir DIR;
    
  NTW: foreach my $file (@@files) {
      $ntw_links{$file} = 1;
  }

    print "reading links in $ntm_dir\n" if $verbose;
    opendir DIR, $ntm_dir or die "$prog_name: can't opendir $ntm_dir: $!";
    my @@files = grep { ! /^\./ && -f "$ntm_dir/$_" } readdir(DIR);
    closedir DIR;
    
  NTM: foreach my $file (@@files) {
      $ntm_links{$file} = 1;
  }

    print "reading html files in $pkg_dir\n" if $verbose;
    opendir DIR, $pkg_dir or die "$prog_name: can't opendir $pkg_dir: $!";
    my @@files = grep { ! /^\./ && -f "$pkg_dir/$_" } readdir(DIR);
    closedir DIR;
    
  HTML: foreach my $file (@@files) {
      if (my $st = stat ("$pkg_dir/$file")) {
	  $htmls{$file}{mtime} = $st->mtime;
      } else {
	  die "$prog_name cannot stat $pkg_dir/$file: $!";
      }
  }
}

# Delete stale files.
sub delete_stale {
    foreach my $file (keys %ntw_links) {
	print "deleting $ntw_dir/$file\n" if $verbose;
	unlink $ntw_dir . "/" . $file;
    }
    foreach my $file (keys %ntm_links) {
	print "deleting $ntm_dir/$file\n" if $verbose;
	unlink $ntm_dir . "/" . $file;
    }
    foreach my $file (keys %htmls) {
	print "deleting $html_dir/packages/$file\n" if $verbose;
	unlink $html_dir . "/packages" . "/" . $file;
    }
}

# Read all binary rpms.
sub read_all_rpms
{
  read_rpms "m68kmint";
  read_rpms "noarch";
  
  # Check if there are lone source rpms left.
  foreach (keys %srpms) {
    if ($srpms{$_}{used} != 1) {
        print STDERR "$prog_name: warning: no binary rpms for $srpms_dir/$_\n";
    }
  }
}

sub read_rpms
{
    my $arch = $_[0];
    my $dir = $rpms_dir . "/$arch";
    my $packagesize, $packagedate;
    my $queryformat = ""
      . "%{name}|%{version}|%{release}|%{arch}|"
      . "%{prefixes}|%{vendor}|%{buildtime}|%{group}|%{size}|"
      . "%{sourcerpm}|%{license}|%{packager}|"
      . "%{url}|%{os}|"
      . "%{changelogname}|%{changelogtime}|%{changelogtext}|%{serial}|"
      . "%{summary}|%{description}|";
  
  opendir DIR, $dir or die "$prog_name: can't opendir $dir: $!";
  my @@files = grep { ! /^\./ && -f "$dir/$_" } readdir(DIR);
  closedir DIR;
  
  BINARY_RPM: foreach my $file (@@files) {
    my $fullname = $dir . "/" . $file;
    print "querying $file ...\n" if $verbose;
    open RPM, "$rpm -qp --queryformat '$queryformat' $fullname |"
      or die "$prog_name: error: rpm -qp $fullname failed";
    $query = "";
    while (<RPM>) {
      s,^\s*$,<P>\n,g;
      $query .= $_;
    }
    close RPM;
    
    # Chmod to 0444.
    chmod 0444, $fullname or die "cannot chmod 0444 $fullname: $!";
    
    my ($package, $version, $release, $buildarch, $prefixes, $vendor,
        $buildtime, $group, $size, $sourcerpm, $license, $rpmpackager,
        $url, $os, $changelogname, $changelogtime, $changelogtext, 
        $serial, $summary, $description) = split /\|/, $query; 
    my $rc = 0xffff & $?;
    
    if ($rc & 0xff00) {
      die "$prog_name: error: $rpm -qp $fullname failed: $!";
    } elsif ($rc > 0x80) {
      $rc >>= 8;
      print STDERR "$prog_name: warning: skipping $fullname\n";
      next BINARY_RPM;
    } elsif ($rc != 0) {
      print STDERR "$prog_name: warning: $rpm -qp $fullname: ";
      if ($rc & 0x80) {
        $rc &= ~0x80;
	print STDERR "core dump from ";
      } else {
        print STDERR "killed by ";
      }
      print STDERR "signal $rc\n";
      next BINARY_RPM;	
    }

    open RPM, "$rpm -qp --provides $fullname |"
      or die "$prog_name: error: rpm -qp --provides $fullname failed";
    $provides = "";
    while (<RPM>) {
      chomp;
      $provides .= "  <LI>$_<BR>\n";
    }
    close RPM;
    
    if ($rc & 0xff00) {
      die "$prog_name: error: $rpm -qp --provides $fullname failed: $!\n";
    } elsif ($rc != 0) {
      print STDERR "$prog_name: warning: $rpm -qp --provides $fullname: ";
      if ($rc & 0x80) {
        $rc &= ~0x80;
	print STDERR "core dump from ";
      } else {
        print STDERR "killed by ";
      }
      print STDERR "signal $rc\n";
    }

    open RPM, "$rpm -qp --requires $fullname |"
      or die "$prog_name: error: rpm -qp --requires $fullname failed";
    $requires = "";
    while (<RPM>) {
      chomp;
      $requires .= "  <LI>$_<BR>\n";
    }
    close RPM;
    
    if ($rc & 0xff00) {
      die "$prog_name: error: $rpm -qp --requires $fullname failed: $!";
    } elsif ($rc != 0) {
      print STDERR "$prog_name: warning: $rpm -qp --requires $fullname: ";
      if ($rc & 0x80) {
        $rc &= ~0x80;
	print STDERR "core dump from ";
      } else {
        print STDERR "killed by ";
      }
      print STDERR "signal $rc\n";
    }

    open RPM, "$rpm -qp --conflicts $fullname |"
      or die "$prog_name: error: rpm -qp --conflicts $fullname failed";
    $conflicts = "";
    while (<RPM>) {
      chomp;
      $conflicts .= "  <LI>$_<BR>\n";
    }
    close RPM;
    
    if ($rc & 0xff00) {
      die "$prog_name: error: $rpm -qp --conflicts $fullname failed: $!";
    } elsif ($rc != 0) {
      print STDERR "$prog_name: warning: $rpm -qp --conflics $fullname: ";
      if ($rc & 0x80) {
        $rc &= ~0x80;
	print STDERR "core dump from ";
      } else {
        print STDERR "killed by ";
      }
      print STDERR "signal $rc\n";
    }

    if ($serial ne "(none)") {
      if ("$file" ne "$package" . "-$version" . "-$release" 
                     . ".$arch" . ".rpm") {
        print STDERR "$prog_name: warning: skipping $file\n";
        print STDERR "(Please rename $file to $package"
          . "-$version" . "-$release.$arch.rpm\n";
        next BINARY_RPM;
      }
    }
    
    # Check correct architecture.
    if ($arch ne $buildarch) {
      print STDERR "$prog_name: warning: $file: not for architecture $arch\n";
    }
    
    # Check for vendor Sparemint.
    if ($vendor ne "Sparemint") {
      print STDERR "$prog_name: warning: $file: vendor ($vendor) is not Sparemint\n";
    }
    
    # Check if we know the packager.
    if ($packager eq "(none)") {
      print STDERR "$prog_name: warning: $file: no packager specified\n";
    } else {
      ($packager, undef) = canonicalize_address ($rpmpackager, $fullname);
    }
    
    # Check for a group.
    if ($group eq "(none)") {
      print STDERR "$prog_name: warning: $file: no group specified\n";
    }
    
    # Check if we have a corresponding source rpm.
    if (!$srpms{$sourcerpm}) {
      print STDERR "$prog_name: warning: $file: source rpm $sourcerpm is missing\n";
    } else {
      $srpms{$sourcerpm}{used} = 1;
    }
    
    if (my $st = stat ($fullname)) {
	$packagesize = $st->size;
	$packagedate = $st->mtime;
	if ($now < $packagedate + $one_week) {
	    my $pfullname = "$package-$version-$release.$arch.rpm";
	    if ($ntw_links{$pfullname} != 1) {
		my $link = "../RPMS/$arch/$pfullname";
		my $target = "$ntw_dir/$pfullname";
		symlink $link, $target
		    or die "$prog_name: error: cannot symlink $link to $target: $!\n";
		print "symlink $link to $target\n" if $verbose;
	    } else {
		delete $ntw_links{$pfullname};
	    }
	}
	if ($now < $packagedate + $one_month) {
	    my $pfullname = "$package-$version-$release.$arch.rpm";
	    if ($ntm_links{$pfullname} != 1) {
		my $link = "../RPMS/$arch/$pfullname";
		my $target = "$ntm_dir/$pfullname";
		symlink $link, $target
		    or die "$prog_name: error: cannot symlink $link to $target: $!\n";
		print "symlink $link to $target\n" if $verbose;
	    } else {
		delete $ntm_links{$pfullname};
	    }
	}
    } else {
	die "$prog_name: error: cannot stat $fullname: $!\n";
    }

    # OK, the file is fine, save the information.
    $rpms{$file}{package} = $package;
    $rpms{$file}{version} = $version;
    $rpms{$file}{release} = $release;
    $rpms{$file}{size} = $size;
    $rpms{$file}{packagesize} = $packagesize;
    $rpms{$file}{packagedate} = $packagedate;
    if ($now < $packagedate + $one_week) {
      $rpms{$file}{ntw} = 1;
    }
    if ($now < $packagedate + $one_month) {
      $rpms{$file}{ntm} = 1;
    }
    $rpms{$file}{arch} = $arch;
    $rpms{$file}{srpm} = $sourcerpm;
    $rpms{$file}{summary} = $summary;
    $rpms{$file}{group} = $group;
    $rpms{$file}{packager} = $packager;
    $rpms{$file}{rpmpackager} = $rpmpackager;
    $rpms{$file}{vendor} = $vendor;
    $rpms{$file}{description} = $description;
    $rpms{$file}{changelogname} = $changelogname;
    $rpms{$file}{changelogtime} = $changelogtime;
    $rpms{$file}{changelogtext} = $changelogtext;
    $rpms{$file}{buildtime} = $buildtime;
    $rpms{$file}{relocations} = $prefixes;
    $rpms{$file}{requires} = $requires;
    $rpms{$file}{provides} = $provides;
    $rpms{$file}{conflicts} = $conflicts;
    $rpms{$file}{os} = $os;
    $rpms{$file}{url} = $url;
    $rpms{$file}{license} = $license;
  }
}

sub expire_rpms 
{
    print "Moving expired source rpms if any\n" if $verbose;

    my $last_package = "";
    my $last_file = "";
    foreach my $file (sort { uc ($a) cmp uc ($b) } keys %srpms) {
	if ($srpms{$file}{package} eq $last_package) {
	    # Duplicate, move the older one.
	    my $older = $file;
	    my $newer = $last_file;
	    if ($srpms{$older}{mtime} > $srpms{$newer}{mtime}) {
		$older = $last_file;
		$newer = $file;
	    }
	    print "$prog_name: Moving expired file $older to $expired_dir\n";
	    rename $srpms_dir . "/" . $older, $expired_dir . "/" . $older;
	    unlink $ntw_dir . "/" . $older;
	    unlink $ntm_dir . "/" . $older;
	    $file = $newer;
	    delete $srpms{$older};
	}
	$last_file = $file;
	$last_package = $srpms{$file}{package};
    }

    print "Moving expired binary rpms if any\n" if $verbose;

    $last_package = "";
    $last_file = "";
    foreach my $file (sort { uc ($a) cmp uc ($b) } keys %rpms) {
	if ($rpms{$file}{package} eq $last_package) {
	    # Duplicate, move the older one.
	    my $older = $file;
	    my $newer = $last_file;
	    if ($rpms{$older}{packagedate} > $rpms{$newer}{packagedate}) {
		$older = $last_file;
		$newer = $file;
	    }
	    print "$prog_name: Moving expired file $older to $expired_dir\n";
	    my $arch = $rpms{$older}{arch};
	    rename $rpms_dir . "/" . $arch . "/" . $older,  $expired_dir . "/" . $older;
	    unlink $ntw_dir . "/" . $older;
	    unlink $ntm_dir . "/" . $older;
	    # FIXME: Remove link if already written.
	    $file = $newer;
	    delete $rpms{$older};
	}
	$last_file = $file;
	$last_package = $rpms{$file}{package};
    }
}

sub canonicalize_address {
  my $fullname, $address;
  my ($parse, $filename) = @@_;

  $_ = $parse;
  # Remove trailing and leading whitespace.
  s,^\s+,,g;
  s,\s$,,g;
  
  my $address_pattern = ".+\@@.+\..+";
    
  # We support three different formats for mail addresses:
  #   Bill Clinton <president@@whitehouse.gov>
  #   Bill Clinton (president@@whitehouse.gov)
  #   president@@whitehouse.gov (Bill Clinton)
  
  if (/(.*)\s*\<($address_pattern)\>$/) {
    $fullname = $1;
    $address = $2;
  } elsif (/(.*)\s*\(($address_pattern)\)$/) {
    $fullname = $1;
    $address = $2;
  } elsif (/($address_pattern)\s*\((.*\))$/) {
    $fullname = $2;
    $address = $1;
  } else {
    print STDERR "$prog_name: cannot parse email address \`$_' in $filename\n";
    return ("unknown");
  }
  
  $address =~ s,\s,,g;
  $fullname =~ s,^\s+,,g;
  $fullname =~ s,\s+$,,g;
  $fullname =~ s,\s+, ,g;
  
  return ($fullname, $address);
}

# Read packages file.
sub read_packages {
  print "parsing $package_list\n" if $verbose;
  open PACKAGE, $package_list 
      or die "$prog_name: can't open $package_list for reading: $!";
  my $lineno = 0;
  
  PACKAGE: while (<PACKAGE>) {
    $lineno++;
    chomp;
    s,#.*$,,g;
    next PACKAGE if /^[ \t]*$/;
    my ($package, $status, $tag, $newtag) = split /\|/;
    
    next PACKAGE if (!$package);
    
    $packages{$package}{tag} = $tag;
    $packages{$package}{status} = $status;
    if ($status eq "a") {
      $packages{$package}{long_status} = "assigned";
    } elsif ($status eq "o") {
      $packages{$package}{long_status} = "orphaned";
    } elsif ($status eq "r") {
      $packages{$package}{long_status} = "released";
    } elsif ($status eq "w") {
      $packages{$package}{long_status} = "waiting";
    } elsif (!$status or $status eq "") {
      $packages{$package}{status} = "w";
      $packages{$package}{long_status} = "waiting";
    } else {
      print STDERR "$prog_name: $package_list: $lineno: warning: unknown status \`$status'\n";
      $packages{$package}{long_status} = "unknown";
    }
    $packages{$package}{newtag} = $newtag;
    
    # Check if we know the tag.
    if ($tag && !$authors{$tag}) {
      print STDERR "$prog_name: $package_list: $lineno: warning: unknown maintainer tag \`$tag'\n";
      print STDERR "$prog_name: (Please edit $authors_list to fix that.)\n";
    }
    if ($newtag && !$authors{$newtag}) {
      print STDERR "$prog_name: $package_list: $lineno: warning: unknown new maintainer tag \`$tag'\n";
      print STDERR "$prog_name: (Please edit $authors_list to fix that.)\n";
    }
    
    # If assigned we need a new maintainer.
    if ($status eq "a" and !$newtag) {
      print STDERR "$prog_name: $package_list: $lineno: package $package: warning: when assigned you have to specify a new maintainer\n";
    }
    
  }
  
  close PACKAGE;
}

# Write files intended for ftp users.
sub write_ftp_files {
  my $file = $sparemint_dir . "/AUTHORS";
  print "creating $file\n" if $verbose;
  open AUTHORS, ">$file"
      or die "$prog_name: can't open $file for writing: $!";
  
  print AUTHORS "The following people have built software packages for Sparemint:\n\n";
  
  foreach my $author (sort keys %authors) {
    print AUTHORS "$authors{$author}{name} <$authors{$author}{email}>\n";
  }

  $generated = gmtime;
  $generated = "Generated automatically " 
      . $generated . " UTC by $prog_name Revision $Version.\n";
  
  print AUTHORS $generated;  
  close AUTHORS or die "$prog_name: cannot close  $file: $!";

  $file = $sparemint_dir . "/PACKAGES";
  print "creating $file\n" if $verbose;
  open PACKAGES, ">$file"
      or die "$prog_name: can't open $file for writing: $!";
  
  print PACKAGES "These packages are currently available for Sparemint:\n\n";
  
  foreach my $package (sort { uc ($a) cmp uc ($b) } keys %rpms) {
    my $number;
    my $date = gmtime $rpms{$package}{packagedate};
    print PACKAGES "$rpms{$package}{package}, version $rpms{$package}{version}, "
                   . "release $rpms{$package}{release}\n";
    print PACKAGES "Group: $rpms{$package}{group}\n";
    print PACKAGES "Summary: $rpms{$package}{summary}\n";
    print PACKAGES "Available since: $date UTC\n";
    print PACKAGES "Download: RPMS/$rpms{$package}{arch}/$package\n";
    $number = format_number $rpms{$package}{packagesize};
    print PACKAGES "Package size: $number bytes\n";
    $number = format_number $rpms{$package}{size};
    print PACKAGES "Installed size: $number bytes\n";
    print PACKAGES "Sources: SRPMS/$rpms{$package}{srpm}\n";
    print PACKAGES "\n";
  }
  
  $generated = gmtime;
  $generated = "Generated automatically " 
      . $generated . " UTC by $prog_name Revision $Version.\n";
  
  print PACKAGES $generated;  
  close PACKAGES or die "$prog_name: cannot close  $file: $!";
}

sub format_number {
  my $number = $_[0];
  my $formatted;
  my $next_group;
  
  $next_group = $number % 1000;
  $number = int ($number / 1000);
  if ($number > 0) {
    if ($next_group < 10) {
      $next_group = "00". $next_group;
    } elsif ($next_group < 100) {
      $next_group = "0" . $next_group;
    }
  }
  $formatted = $next_group;
  while ($number > 0) {
    $next_group = $number % 1000;
    $number = int ($number / 1000);
    if ($number > 0) {
      if ($next_group < 10) {
        $next_group = "00". $next_group;
      } elsif ($next_group < 100) {
        $next_group = "0" . $next_group;
      }
    }
    $formatted = $next_group . ",$formatted";
  }
  
  return $formatted;
}

# Write AUTHORS file for http users.
sub write_authors_html {
  #print "removing $html_dir/*.html\n" if $verbose;
  #`rm -f $html_dir/*.html`;
  #print "removing $pkg_dir/*.html\n" if $verbose;
  #`rm -f $pkg_dir/*.html`;
  
  my $file = $html_dir . "/AUTHORS.html";
  print "creating $file\n" if $verbose;
  open AUTHORS, ">$file"
      or die "$prog_name: can't open $file for writing: $!";

  print AUTHORS <<EOF;
<HTML>

<HEAD>
  <TITLE>Sparemint Authors</TITLE>
  <LINK rel="stylesheet" href="../sparemint.css" type="text/css">
</HEAD>

  <BODY BGCOLOR=white>
   <A HREF="../arts.html">
     <IMG ALIGN=right SRC="images/spare_small.jpeg" ALT="Sparemint logo" BORDER=0>
   </A>
   <H1>Sparemint Authors</H1>
   The following people are contributing to the Sparemint project by
   maintaining software packages:
   <UL>
EOF

  foreach my $author (sort keys %authors) {
    print AUTHORS <<EOF;
     <LI>$authors{$author}{name}
     <UL>
       <LI>Mail: <A HREF="mailto:$authors{$author}{email}">
           $authors{$author}{email}</A>
EOF
    if ($authors{$author}{http}) {
      print AUTHORS <<EOF;
       <LI>URL: <A HREF="$authors{$author}{http}">
           $authors{$author}{http}</A>
EOF
    }
    print AUTHORS "    </UL>\n";
  }
  
  print AUTHORS "  </UL>\n";

  $generated = gmtime;
  $generated = "<SMALL>Generated automatically " 
      . $generated . " UTC by "
      . "<A HREF=\"sitebin/buildsite.html\">$prog_name</A>"
      . " Revision $Version.</SMALL>\n";
  
  print AUTHORS "$generated\n";

  close AUTHORS or die "$prog_name: cannot close  $file: $!";
}

$total_size = 0;
$total_installed_size = 0;
$number_of_packages = 0;

# Write alphabetical package list.
sub write_alpha_packages {
  my $file;
  my $what = $_[0];
  my $silent = 1;
  my $written_packages = 0;
  
  if ($what eq "ntw") {
    $file = $html_dir . "/new-this-week.html";
  } elsif ($what eq "ntm") {
    $file = $html_dir . "/new-this-month.html";
  } else {
    $file = $html_dir . "/packages.html";
  }
  
  print "creating $file\n" if $verbose;
  open PACKAGES, ">$file"
      or die "$prog_name: can't open $file for writing: $!";

  if ($what eq "ntw") {
    my $since = gmtime ($now - $one_week);
    print PACKAGES <<EOF;
<HTML>

<HEAD>
  <TITLE>This Week's New Sparemint Packages</TITLE>
  <LINK rel="stylesheet" href="../sparemint.css" type="text/css">
</HEAD>

  <BODY BGCOLOR=white>
    <A HREF="../arts.html">
      <IMG ALIGN=right SRC="images/spare_small.jpeg" ALT="Sparemint logo" BORDER=0>
    </A>
    <H1>This Week's New Sparemint Packages</H1>
    These packages have been uploaded to the Sparemint server during the last
    week (since $since UTC):   
EOF
  } elsif ($what eq "ntm") {
    my $since = gmtime ($now - $one_month);
    print PACKAGES <<EOF;
<HTML>

<HEAD>
  <TITLE>This Month's New Sparemint Packages</TITLE>
  <LINK rel="stylesheet" href="../sparemint.css" type="text/css">
</HEAD>

  <BODY BGCOLOR=white>
    <A HREF="../arts.html">
      <IMG ALIGN=right SRC="images/spare_small.jpeg" ALT="Sparemint logo" BORDER=0>
    </A>
    <H1>This Month's New Sparemint Packages</H1>
    These packages have been uploaded to the Sparemint server during the last
    month (since $since UTC):
EOF
  } else {  
    $silent = 0;
    print PACKAGES <<EOF;
<HTML>
<HEAD>
  <TITLE>Sparemint Packages Alphabetically Sorted</TITLE>
  <LINK rel="stylesheet" href="../sparemint.css" type="text/css">
</HEAD>

  <BODY BGCOLOR=white>
    <A HREF="../arts.html">
      <IMG ALIGN=right SRC="images/spare_small.jpeg" ALT="Sparemint logo" BORDER=0>
    </A>
    <H1>Sparemint Packages Alphabetically Sorted</H1>
    These packages are currently available for Sparemint:
EOF
  }
  
  print PACKAGES <<EOF;
    <P>  
    <DIV ALIGN=center>
      <H3>Quick alphabetical index:</H3>
EOF

  my $last;
  PACKAGE: foreach my $package (sort { uc ($a) cmp uc ($b) } keys %rpms) {
    next PACKAGE if $what eq "ntw" and !$rpms{$package}{ntw};
    next PACKAGE if $what eq "ntm" and !$rpms{$package}{ntm};
    
    $written_packages++;

    my $current = substr $package, 0, 1;
    if (uc ($current) ne uc ($last)) {
      $last = uc ($current);
      print PACKAGES "    <A HREF=#$last>$last</A>\n";
    }
  }
  
  print PACKAGES <<EOF; 
      </DIV>
   <UL>
   
EOF

  $last = "\000";
  PACKAGE: foreach my $package (sort { uc ($a) cmp uc ($b) } keys %rpms) {
    next PACKAGE if $what eq "ntw" and !$rpms{$package}{ntw};
    next PACKAGE if $what eq "ntm" and !$rpms{$package}{ntm};
    
    my $number;
    my $name = $rpms{$package}{package};
    my $group = $rpms{$package}{group};
    my $summary = $rpms{$package}{summary};
    my $packagesize = $rpms{$package}{packagesize};
    my $version = $rpms{$package}{version};
    my $release = $rpms{$package}{release};
    my $current = substr $package, 0, 1;
    my $description = $rpms{$package}{description};
    my $vendor = $rpms{$package}{vendor};
    my $fpackagesize = format_number $packagesize;
    my $fsize = format_number $rpms{$package}{size};
    
    if (uc ($current) ne uc ($last)) {
      $last = uc ($current);
      print PACKAGES "    <A NAME=$last><H2>$last</H2></A>\n";
    }

    my $new1 = "";
    my $new2 = "";
    if (!$silent) {
      if ($rpms{$package}{ntw}) {
        $new1 = "<IMG SRC=\"images/new_this_week.gif\" ALT=\"New this week!\" ALIGN=middle>";
        $new2 = "<IMG SRC=\"../images/new_this_week.gif\" ALT=\"New this week!\" ALIGN=middle>";
      } elsif ($rpms{$package}{ntm}) {
        $new1 = "<IMG SRC=\"images/new_this_month.gif\" ALT=\"New this month!\" ALIGN=middle>";
        $new2 = "<IMG SRC=\"../images/new_this_month.gif\" ALT=\"New this month!\" ALIGN=middle>";
      }
    }
    
    print PACKAGES "    <LI>$name $new1\n";
    print PACKAGES "      <DL>\n";
    print PACKAGES "        <DD>Summary: $summary\n";
    $number = format_number $packagesize;
    print PACKAGES <<EOF;
        <DD><A HREF="packages/$name.html">Information</A><BR>
            <A HREF="../RPMS/$rpms{$package}{arch}/$package">Download</A>
              $number bytes
      </DL>
EOF

    next PACKAGE if $silent;  	# If silent then we don't need the rest.
    				# The detailed file has already been
    				# written.

    $number_of_packages++;
    $total_size += $packagesize;
    $total_installed_size += $rpms{$package}{size};

    # Check if we have the package listed in PACKAGES.in.
    my $maintainer;
    my $tag = 0;
    unless ($packages{$name}{tag}) {
      if (!$silent) {
        print STDERR "$prog_name: warning: package $name not listed in $package_list\n";
      }
    } else {
      $packages{$name}{used} = 1;
      $tag = $packages{$name}{tag};
      # Check if the maintainer is correct.
      $maintainer = $authors{$tag}{name};
      if ($maintainer ne $rpms{$package}{packager}) {
        if (!$silent) {
          print STDERR "$prog_name: warning: $package_list says that $maintainer maintains $package, not $rpms{$package}{packager}\n";
        }
      }
    }
    
    # Check if we have a source rpm.
    my $sourcerpm = "";
    if ($rpms{$package}{srpm}) {
      $sourcerpm = $rpms{$package}{srpm};
      if ($sourcerpm) {
        $fparen_srcsize = format_number $srpms{$sourcerpm}{size};
        $fparen_srcsize = " (" . $fparen_srcsize . " bytes)";
      } else {
        if (!$silent) {
          print STDERR "$prog_name: warning: no source rpm for $package\n";
        }
      }
    }

    # Write a complete changelog line.
    my $changelog = "";
    if ($rpms{$package}{changelogname} ne "(none)") {
      $changelog = $rpms{$package}{changelogtext};
      my $fdate = gmtime $rpms{$package}{changelogtime};
      $changelog =~ s,\n,<BR>\n,g;
      $changelog = "<LI>Last change: $rpms{$package}{changelogname} $fdate UTC<BR>\n"
                 . $changelog;
    }
    
    my $buildtime = gmtime $rpms{$package}{buildtime};
    my $uploadtime = gmtime $rpms{$package}{packagedate};
    my $size = format_number $rpms{$package}{size};
    my $relocations = $rpms{$package}{relocations};
    
    # If the file already exists then check if it needs rewriting.
    my $info_html = "$pkg_dir/$name.html";
    if ($htmls{"$name.html"}{mtime} > 0) {
	my $html_mtime = $htmls{"$name.html"}{mtime};
	delete $htmls{"$name.html"};
	if ($rpms{$package}{packagedate} < $html_mtime) {
	    next PACKAGE;
	}
    }

    delete $htmls{"$name.html"};

    # Write all provides.
    my $provides = $rpms{$package}{provides};
    if ($provides) {
      $provides = "<LI>Provides:<UL>\n" . $provides . "</UL>\n"; 
    }
            
    # Write all requires.
    my $requires = $rpms{$package}{requires};
    if ($requires) {
      $requires = "<LI>Requires:<UL>\n" . $requires . "</UL>\n"; 
    }
            
    # Write all conflicts.
    my $conflicts = $rpms{$package}{conflicts};
    if ($conflicts) {
      $conflicts = "<LI>Conflicts:<UL>\n" . $conflicts . "</UL>\n"; 
    }
            
    my $full_packager;
    if ($tag eq "") {
      $full_packager = $rpms{$package}{rpmpackager};
    } else {
      if ($authors{$tag}{http} eq "") {
        $full_packager="$authors{$tag}{name}"
          . " (<A HREF=\"mailto:$authors{$tag}{email}\">$authors{$tag}{email}</A>)"
      } else {
        $full_packager = "<A HREF=\"$authors{$tag}{http}\">$authors{$tag}{name}</A>"
          . " (<A HREF=\"mailto:$authors{$tag}{email}\">$authors{$tag}{email}</A>)";
      }
    }

    my $os = $rpms{$package}{os};
    my $license = $rpms{$package}{license};
    my $url = $rpms{$package}{url};
    unless ($url eq "(none)") {
	$url = "<LI>URL: <A HREF=\"$url\">$url</A><BR>";
    } else {
	$url = "";
    }
    
    if ($group eq "(none)") {
      $group = "";
    } else {
      $group = "<LI>Group: <A HREF=\"../groups.html#$group\">$group</A>";
    }

    # Write the info html document.
    print "creating $pkg_dir/" . "$name.html\n" if $verbose;
    open INFO, ">$pkg_dir/$name.html"
      or die "$prog_name: cannot create $pkg_dir/$name.html: $!";

    print INFO <<EOF;
<HTML>

<HEAD>
  <TITLE>Sparemint - $name, version $version, release $release</TITLE>
  <LINK rel="stylesheet" href="../../sparemint.css" type="text/css">
</HEAD>
  
  <BODY BGCOLOR=white>
    <A HREF="../../arts.html">
      <IMG ALIGN=right SRC="../images/spare_small.jpeg" ALT="Sparemint logo" BORDER=0>
    </A>

    <H1>$name</H1>

<UL> 
<LI>Summary: $summary<BR>
$url
<LI>Version: $version<BR>
<LI>Release: $release<BR>
$group
<LI>License: $license</BR>
<LI>Installation size: $size bytes<BR>
<LI>Operating system: $os<BR>
$provides
$requires
$conflicts
<LI>Relocations: $relocations<BR>
<LI>Build date: $buildtime UTC<BR>
<LI>Upload date: $uploadtime UTC<BR>
<LI>Packager: $full_packager<BR>
<LI>Vendor: $vendor<BR>
<LI>Sources: <A HREF="../../SRPMS/$sourcerpm">$sourcerpm</A> $fparen_srcsize<BR>
$changelog
<LI>Description:<BR>
$description
</UL>
<P>
<H2><A HREF="../../RPMS/$rpms{$package}{arch}/$package">Download</A></H2> ($fpackagesize bytes)
<DIV ALIGN=right>
  <A HREF="../../index.html"><IMG SRC="../images/top.gif" ALT="Top" BORDER=0></A>
  <A HREF="../packages.html"><IMG SRC="../images/a-z.gif" ALT="A-Z" BORDER=0></A>
</DIV>
EOF

    $generated = gmtime;
    $generated = "<SMALL>Generated automatically " 
        . $generated . " UTC by "
        . "<A HREF=\"../../sitebin/buildsite.html\">$prog_name</A>"
        . " Revision $Version.</SMALL>\n";
  
    print INFO "<HR>\n$generated\n";
    close INFO or die "$prog_name: cannot close  $pkg_dir/$name.html: $!";
  }
  
  $number_of_packages = format_number $number_of_packages;
  $total_size = format_number $total_size;
  $total_installed_size = format_number $total_installed_size;
  
  print PACKAGES "  </UL>\n";

  if (!$silent) {
    print PACKAGES <<EOF;
  
    <HR>
    $total_size bytes in $number_of_packages binary packages.  Installation
    size totals to $total_installed_size bytes.
EOF
  }
  if ($what eq "ntw" and $written_packages == 0) {
    print PACKAGES "  <EM>No packages uploaded this week!</EM>\n";
  } elsif ($what eq "ntm" and $written_packages == 0) {
    print PACKAGES "  <EM>No packages uploaded this month!</EM>\n";
  } 
  
  $generated = gmtime;
  $generated = "<SMALL>Generated automatically " 
      . $generated . " UTC by "
      . "<A HREF=\"../sitebin/buildsite.html\">$prog_name</A>"
      . " Revision $Version.</SMALL>\n";
  
  print PACKAGES <<EOF;
<DIV ALIGN=right>
  <A HREF="../index.html"><IMG SRC="images/top.gif" ALT="Top" BORDER=0></A>
</DIV>
    <HR>
    $generated
EOF

  close PACKAGES or die "$prog_name: cannot close  $file: $!";
  
  # Some additional checks for PACKAGES.in.
  foreach $package (keys %packages) {
    # Orphaned and released packages must exist.
    my $status = $packages{$package}{status};
    my $long_status = $packages{$package}{status};
    
    if (($status eq "r" or $status eq "o") and !$packages{$package}{used}) {
      print STDERR "$prog_name: warning: $package has status \`$long_status' in $package_list but no binary rpm\n";
    } elsif (($status ne "r" and $status ne "o" and $status ne "a") and $packages{$package}{used}) {
      print STDERR "$prog_name: warning: $package has status \`$long_status' in $package_list but there is already a binary rpm\n";
    }    
  }  
}

# Write package list sorted by group.
sub write_group_packages {
  my $file = $html_dir . "/groups.html";
  
  print "creating $file\n" if $verbose;
  open PACKAGES, ">$file"
      or die "$prog_name: can't open $file for writing: $!";
  
  print PACKAGES <<EOF;
<HTML>

<HEAD>
  <TITLE>Sparemint Packages Sorted By Group</TITLE>
  <LINK rel="stylesheet" href="../sparemint.css" type="text/css">
</HEAD>

  <BODY BGCOLOR=white>
    <A HREF="../arts.html">
      <IMG ALIGN=right SRC="images/spare_small.jpeg" ALT="Sparemint logo" BORDER=0>
    </A>
    <H1>Sparemint Sorted by Group</H1>
    The Sparemint packages belong to one of these groups:
   
    <P>
EOF

  my $last = "";;
  foreach my $package (sort by_group keys %rpms) {
    my $current = $rpms{$package}{group};
    if (uc ($current) ne uc ($last)) {
      $last = $current;
      print PACKAGES "    <A HREF=#$last>$last</A><BR>\n";
    }
  }
  
  $last = "";
  foreach my $package (sort by_group keys %rpms) {
    my $group = $rpms{$package}{group};
    my $number;
    my $name = $rpms{$package}{package};
    my $summary = $rpms{$package}{summary};
    my $packagesize = $rpms{$package}{packagesize};
    my $version = $rpms{$package}{version};
    my $release = $rpms{$package}{release};
    my $fpackagesize = format_number $packagesize;
    my $fsize = format_number $rpms{$package}{size};
    
    if (uc ($group) ne uc ($last)) {
      if ($last) {
        print PACKAGES "  </UL>\n";
      }
      $last = $group;
      print PACKAGES "    <A NAME=$last><H2>$last</H2></A>\n";
      print PACKAGES "  <UL>\n";
    }
    
    my $new = "";
    if ($rpms{$package}{ntw}) {
      $new = "<IMG SRC=\"images/new_this_week.gif\" ALT=\"New this week!\" ALIGN=middle>";
    } elsif ($rpms{$package}{ntm}) {
      $new = "<IMG SRC=\"images/new_this_month.gif\" ALT=\"New this month!\" ALIGN=middle>";
    }
    print PACKAGES "    <LI>$name $new\n\n";
    print PACKAGES "      <DL>\n";
    print PACKAGES "        <DD>Summary: $summary\n";
    $number = format_number $packagesize;
    print PACKAGES <<EOF;
        <DD><A HREF="packages/$name.html">
          Information</A><BR>
            <A HREF="../RPMS/$rpms{$package}{arch}/$package">Download</A>
              $number bytes
      </DL>
EOF

  }

  $generated = gmtime;
  $generated = "<SMALL>Generated automatically " 
      . $generated . " UTC by "
      . "<A HREF=\"../sitebin/buildsite.html\">$prog_name</A>"
      . " Revision $Version.</SMALL>\n";
  
  print PACKAGES <<EOF;
  </UL>
<DIV ALIGN=right>
  <A HREF="../index.html"><IMG SRC="images/top.gif" ALT="Top" BORDER=0></A>
  <A HREF="packages.html"><IMG SRC="images/a-z.gif" ALT="A-Z" BORDER=0></A>
</DIV>
    <HR>
    $generated
EOF
  
  close PACKAGES or die "$prog_name: cannot close  $file: $!";
}

sub by_group 
{
  my $comparison = uc ($rpms{$a}{group}) cmp uc ($rpms{$b}{group});
  
  unless ($comparison) {
    $comparison = uc ($rpms{$a}{package}) cmp uc ($rpms{$b}{package});
  }

  return $comparison;
}

sub write_todos
{
  my $file_html = $html_dir . "/todo.html";
  my $file = $sparemint_dir . "/TODO";
  my $number_of_orphaned_packages = 0;
  my $number_of_waiting_packages = 0;
  my $number_of_assigned_packages = 0;
  
  print "creating $file_html\n" if $verbose;
  print "creating $file\n" if $verbose;
  
  open TODO_HTML, ">$file_html"
      or die "$prog_name: can't open $file_html for writing: $!";
  open TODO, ">$file"
      or die "$prog_name: can't open $file for writing: $!";
  
  print TODO_HTML <<EOF;
<HTML>

<HEAD>
  <TITLE>Sparemint TODO List</TITLE>
  <LINK rel="stylesheet" href="../sparemint.css" type="text/css">
</HEAD>

  <BODY BGCOLOR=white>
    <A HREF="../arts.html">
      <IMG ALIGN=right SRC="images/spare_small.jpeg" ALT="Sparemint logo" BORDER=0>
    </A>
    <H1>Sparemint TODO List</H1>

    <H2>Work in Progress</H2>
    The following packages are already assigned to a maintainer.  They will
    appear here soon.  If you want to take over maintainance for Sparemint
    packages you should rather look in the sections for
      <A HREF="#orphaned">orphaned packages</A>
    or
      <A HREF="#waiting">waiting packages</A>.
    <P>
    <UL>
EOF

  print TODO <<EOF;
Sparemint TODO List
===================

Work in Progress
----------------

The following packages are already assigned to a maintainer.  They will
appear here soon.  If you want to take over maintainance for Sparemint
packages you should rather look in the sections for orphaned packages or
waiting packages (below).

EOF

  foreach my $package (sort keys %packages) {
    if ($packages{$package}{status} eq "a") {
      $number_of_assigned_packages++;

      my $tag = $packages{$package}{newtag};
      my $new_maintainer ="$authors{$tag}{name}";
      my $email = $authors{$tag}{email};
     
      print TODO_HTML <<EOF;
      <LI>$package: <A HREF="mailto:$email">$new_maintainer</A>
EOF
      print TODO <<EOF;
o $package
  New maintainer: $new_maintainer <$email>
EOF
    }    
  }
  
  print TODO_HTML "    </UL>\n";

  if (!$number_of_assigned_packages) {
    print TODO <<EOF;

There are currently no newly assigned packages!

EOF
    print TODO_HTML <<EOF;

<EM>There are currently no newly assigned packages!</EM>

EOF
  }
      
    print TODO_HTML <<EOF;
    <A NAME="orphaned"><H2>Orphaned packages</H2></A>
    The following packages are currently orphaned.  There is a binary
    package available but it may be outdated because the last maintainer
    has abandoned the package.
    <P>
    Please contact the Sparemint project if you are interested in
    taking over maintainance for one of these packages.
    <P>
    <UL>
EOF

    print TODO <<EOF;

Orphaned packages
-----------------

The following packages are currently orphaned.  There is a binary
package available but it may be outdated because the last maintainer
has abandoned the package.

Please contact the Sparemint project if you are interested in
taking over maintainance for one of these packages.

EOF

  foreach my $package (sort keys %packages) {
    if ($packages{$package}{status} eq "o") {
      $number_of_orphaned_packages++;

      my $tag = $packages{$package}{tag};
      my $maintainer ="$authors{$tag}{name}";
      my $email = $authors{$tag}{email};
     
      print TODO_HTML <<EOF;
      <LI>$package, old maintainer: <A HREF="mailto:$email">$maintainer</A>
EOF
      print TODO <<EOF;
o $package
  Old maintainer: $maintainer <$email>
EOF
    }    
  }
  
  print TODO_HTML "    </UL>\n";

  if (!$number_of_orphaned_packages) {
    print TODO <<EOF;

There are currently no orphaned packages!

EOF
    print TODO_HTML <<EOF;

<EM>There are currently no orphaned packages!</EM>

EOF
  }
      
  print TODO_HTML <<EOF;
    <H2>Waiting packages</H2>
      The following packages are waiting for a maintainer.  There is
      currently no binary package available, so the new maintainer
      would have to start from the beginning.
      <P>
      Please contact the Sparemint project if you are interested in
      taking over maintainance for one of these packages.
      
    <UL>
EOF

  print TODO <<EOF;

Waiting packages
----------------

The following packages are waiting for a maintainer.  There is
currently no binary package available, so the new maintainer
would have to start from the beginning.

Please contact the Sparemint project if you are interested in
taking over maintainance for one of these packages.

EOF

  foreach my $package (sort keys %packages) {
    if ((!$packages{$package}{status}) or ($packages{$package}{status} eq "w")) {
      $number_of_waiting_packages++;
      print TODO_HTML <<EOF;
      <LI>$package
EOF
      print TODO <<EOF;
o $package
EOF
    }    
  }
  

  print TODO_HTML "    </UL>\n";
  
  if (!$number_of_waiting_packages) {
    print TODO <<EOF;

There are currently no waiting packages!  But if you have an idea for
a new package, you're welcome!

EOF
    print TODO_HTML <<EOF

<EM>There are currently no waiting packages!  But if you have an idea for
a new package, you're welcome!</EM>

EOF
  }      

  $generated = gmtime;
  $generated = "<SMALL>Generated automatically " 
      . $generated . " UTC by "
      . "<A HREF=\"../sitebin/buildsite.html\">$prog_name</A>"
      . " Revision $Version.</SMALL>\n";
  
  print TODO_HTML <<EOF;
<DIV ALIGN=right>
  <A HREF="../index.html"><IMG SRC="images/top.gif" ALT="Top" BORDER=0></A>
  <A HREF="packages.html"><IMG SRC="images/a-z.gif" ALT="A-Z" BORDER=0></A>
</DIV>
<HR>
$generated
EOF

  $generated = gmtime;
  $generated = "Generated automatically " 
      . $generated . " UTC by $prog_name Revision $Version.\n";
  
  print TODO "\n$generated\n";
  
  close TODO_HTML or die "$prog_name: cannot close  $file_html: $!\n";
  close TODO or die "$prog_name: cannot close $file: $!\n";
}
@


1.15
log
@BUGFIX: Permissions in SRPMS/ now get changed to 0444.
@
text
@d20 1
a20 1
# $Id: buildsite.pl,v 1.14 1999/09/05 00:38:21 guido Exp guido $
d38 1
a38 1
$Revision = '$Revision: 1.14 $';
d1460 1
a1460 1
            <A HREF="../../RPMS/$rpms{$package}{arch}/$package">Download</A>
@


1.14
log
@Added missing tag for unsigned list in todo list.
@
text
@d20 1
a20 1
# $Id: buildsite.pl,v 1.13 1999/09/04 20:51:43 guido Exp guido $
d23 2
d38 1
a38 1
$Revision = '$Revision: 1.13 $';
a384 2
      chmod 0444, $fullname;
      
d388 2
d533 1
a533 1
    chmod 0444, $fullname;
@


1.13
log
@HTML files and symbolic links in NEW-THIS-WEEK and NEW-THIS-MONTH only
get rebuilt when necessary.
Added cascading style sheet.
Removed status and new maintainer line from html files.
Only display package URL if available.
Put list of assigned packages into TODO list.
Added maintainer e-mail address in TODO list.
@
text
@d20 1
a20 1
# $Id: buildsite.pl,v 1.12 1999/08/29 00:42:46 guido Exp guido $
d36 1
a36 1
$Revision = '$Revision: 1.12 $';
d1533 1
d1591 1
a1591 1
    
@


1.12
log
@Fixed messed up group list.
Put the "Group: " back in front of group link in html description
files.
Added link to buildsite page.
@
text
@d20 1
a20 1
# $Id: buildsite.pl,v 1.11 1999/08/28 01:54:35 guido Exp guido $
a22 7
# - The site is currently in an undefined state while being build.  This
#   is not tolerable because Murphy says that in that very moment 
#   nother server is attempting to mirror us and will download 
#   inconsistent files.
# - Write a list of currently assigned packages (better than having
#   candidates for contributions look for free packages in TODO
#   resp. TODO.html).
a26 2
# - Don't rewrite html files if not necessary.  This saves bandwidth
#   for mirror sites.
d36 1
a36 1
$Revision = '$Revision: 1.11 $';
d65 1
d120 3
d131 3
d147 1
d152 1
d160 1
d174 6
a179 3
  GetOptions ("--verbose|-v" => $opt_verbose, 
              "--help|-h" => $opt_help, 
              "--version|-V" => $opt_version) 
d242 1
d250 1
a250 1
    $base_dir => 0755,
d263 1
d351 2
a352 5
  
  print "clearing $ntw_dir\n" if $verbose;
  `rm -rf $ntw_dir/*`;
  print "clearing $ntm_dir\n" if $verbose;
  `rm -rf $ntm_dir/*`;
d397 2
d401 9
a409 5
        my $link = "../SRPMS/$name";
        my $target = "$ntw_dir/$name";
        symlink $link, $target
            or die "$prog_name: error: cannot symlink $link to $target: $!\n";
        print "symlink $link to $target\n" if $verbose;
d413 9
a421 5
        my $link = "../SRPMS/$name";
        my $target = "$ntm_dir/$name";
        symlink $link, $target
            or die "$prog_name: error: cannot symlink $link to $target: $!\n";
        print "symlink $link to $target\n" if $verbose;
d432 1
d436 51
d503 4
a506 4
  my $arch = $_[0];
  my $dir = $rpms_dir . "/$arch";
  my $packagesize, $packagedate;
  my $queryformat = ""
d663 26
a688 18
      $packagesize = $st->size;
      $packagedate = $st->mtime;
      if ($now < $packagedate + $one_week) {
        my $pfullname = "$package-$version-$release.$arch.rpm";
        my $link = "../RPMS/$arch/$pfullname";
        my $target = "$ntw_dir/$pfullname";
        symlink $link, $target
            or die "$prog_name: error: cannot symlink $link to $target: $!\n";
        print "symlink $link to $target\n" if $verbose;
      }
      if ($now < $packagedate + $one_month) {
        my $pfullname = "$package-$version-$release.$arch.rpm";
        my $link = "../RPMS/$arch/$pfullname";
        my $target = "$ntm_dir/$pfullname";
        symlink $link, $target
            or die "$prog_name: error: cannot symlink $link to $target: $!\n";
        print "symlink $link to $target\n" if $verbose;
      }
d690 1
a690 1
      die "$prog_name: error: cannot stat $fullname: $!\n";
d728 53
d959 4
a962 4
  print "removing $html_dir/*.html\n" if $verbose;
  `rm -f $html_dir/*.html`;
  print "removing $pkg_dir/*.html\n" if $verbose;
  `rm -f $pkg_dir/*.html`;
d971 2
d974 3
d1043 2
d1046 3
d1061 2
d1064 3
d1079 1
d1081 3
a1179 4
    } elsif ($packages{$name}{used}) {
      if (!$silent) {
        print STDERR "$prog_name: warning: package $package is listed multiple times in $packages_list\n";
      }
d1221 12
a1263 25
    # Status.
    my $status = $packages{$name}{long_status};
    if (!$status) {
      $status = "unknown";
    }
    
    my $new_maintainer = "";
    if ($status eq "assigned") {
      $tag = $packages{$name}{newtag};
      
      if ($tag eq "") {
        $new_maintainer = $rpms{$package}{rpmpackager};
      } else {
        if ($authors{$tag}{http} eq "") {
          $new_maintainer ="$authors{$tag}{name}"
            . " (<A HREF=\"mailto:$authors{$tag}{email}\">$authors{$tag}{email}</A>)"
        } else {
          $new_maintainer = "<A HREF=\"$authors{$tag}{http}\">$authors{$tag}{name}</A>"
            . " (<A HREF=\"mailto:$authors{$tag}{email}\">$authors{$tag}{email}</A>)";
        }
      }
      
      $new_maintainer = "<LI>New maintainer: $new_maintainer<BR>";
    }
    
d1268 3
a1270 1
     $url = "<LI>URL: <A HREF=\"$url\">$url</A><BR>";
d1273 1
a1273 1
    if ($group eq "(none") {
a1279 1
    my $info_html = "$pkg_dir/$name.html";
d1286 2
d1289 3
d1296 1
a1296 1
    $new2
a1314 2
<LI>Status: $status
$new_maintainer
d1399 2
d1402 3
d1501 1
d1513 2
d1516 3
d1524 60
a1583 1
    <H2>Orphaned packages</H2>
d1594 1
a1594 3
  print TODO <<EOF;
Sparemint TODO List
===================
d1611 5
d1617 1
a1617 1
      <LI>$package
d1621 1
d1654 1
@


1.11
log
@Don't write a html anchor if packager has no URL.
Make group description a link to package list sorted by group.
Sort package alpanumerically (case-insensitive) within groups.
New description fields os, url, status, new maintainer.
@
text
@d2 1
a2 1
# buildhtml - Rebuild html versions of Sparemint files.
d20 16
a35 1
# $Id: buildsite.pl,v 1.10 1999/08/22 21:55:22 guido Exp guido $
d45 1
a45 1
$Revision = '$Revision: 1.10 $';
d144 1
d169 4
d189 1
a213 3
  $generated = gmtime;
  $generated = "<SMALL>Generated automatically " . $generated . " UTC by $prog_name Revision $Version.</SMALL>\n";
  
d761 4
d792 4
d874 8
a881 1
  print AUTHORS "<HR>\n$generated\n";
a882 1

d1146 1
a1146 1
      $group = "<LI><A HREF=\"../groups.html#$group\">$group</A>";
d1197 6
d1227 6
d1328 6
d1351 5
a1355 3
  return $comparison unless $comparison;
  
  return uc ($rpms{$a}{name}) cmp uc ($rpms{$b}{name});
d1490 6
d1505 4
@


1.10
log
@Fixed "ALT=" texts for some icons.
@
text
@d20 1
a20 1
# $Id: buildsite.pl,v 1.9 1999/08/22 00:38:13 user Exp guido $
d30 1
a30 1
$Revision = '$Revision: 1.9 $';
d427 3
a429 2
      . "%{summary}|%{description}|"
      . "%{changelogname}|%{changelogtime}|%{changelogtext}|%{serial}";
d452 2
a453 3
        $summary, $description, 
        $changelogname, $changelogtime, $changelogtext, 
        $serial) = split /\|/, $query;
d631 3
d1067 1
a1067 1
    if (-z $tag) {
d1070 1
a1070 1
      if (-z $authors{$tag}{http}) {
d1079 1
a1079 1
    # Status. 
d1082 1
a1082 1
      $status = unknown;
d1089 1
a1089 1
      if (-z $tag) {
d1092 1
a1092 1
        if (-z $authors{$tag}{http}) {
d1104 13
d1135 1
d1138 2
a1139 1
<LI>Group: $group<BR>
d1141 1
d1149 1
d1303 1
a1303 1
  return uc ($rpms{$a}{group}) cmp uc ($rpms{$b}{group});
@


1.9
log
@Bugfix: Made link in groups file relative.
@
text
@d20 1
a20 1
# $Id: buildsite.pl,v 1.8 1999/08/19 17:57:20 user Exp user $
d30 1
a30 1
$Revision = '$Revision: 1.8 $';
d1140 2
a1141 2
  <A HREF="../../index.html" ALT="Top"><IMG SRC="../images/top.gif" BORDER=0></A>
  <A HREF="../packages.html" ALT="A-Z"><IMG SRC="../images/a-z.gif" BORDER=0></A>
d1171 1
a1171 1
  <A HREF="../index.html" ALT="Top"><IMG SRC="images/top.gif" BORDER=0></A>
d1267 2
a1268 2
  <A HREF="../index.html" ALT="Top"><IMG SRC="images/top.gif" BORDER=0></A>
  <A HREF="packages.html" ALT="A-Z"><IMG SRC="images/a-z.gif" BORDER=0></A>
d1420 2
a1421 2
  <A HREF="../index.html" ALT="Top"><IMG SRC="images/top.gif" BORDER=0></A>
  <A HREF="packages.html" ALT="A-Z"><IMG SRC="images/a-z.gif" BORDER=0></A>
@


1.8
log
@Fixed broken links (and made absolute links relative).
Chmod all uploaded files to 0444.
Moved all generated files into "html".
@
text
@d20 1
a20 1
# $Id: buildsite.pl,v 1.7 1999/08/18 23:49:46 root Exp user $
d30 1
a30 1
$Revision = '$Revision: 1.7 $';
d1255 1
a1255 1
        <DD><A HREF="$html_dir/$name.html">
@


1.7
log
@Changed names of graphics.
@
text
@d20 1
a20 19
# $Id: buildsite.pl,v 1.6 1999/08/18 19:58:34 user Exp root $
# $Log: buildsite.pl,v $
# Revision 1.6  1999/08/18 19:58:34  user
# Put package descriptions into html/packages.
# Construct html filenames without version information.
# A lot of bugfixes.
#
# Revision 1.5  1999/08/14 13:59:24  user
# Added Sparemint logo to package descriptions.
#
# Revision 1.4  1999/08/13 14:31:49  user
# Calculate number of orphaned and waiting packages correctly
# and display a descriptive text if it is zero.
# Don't show total sizes in package list sorted by group (spurious bug).
# Don't print a semi-colon after new maintainer.
#
# Revision 1.3  1999/08/11 20:54:24  user
# Various improvements and changes.
#
d30 1
a30 1
$Revision = '$Revision: 1.6 $';
d361 3
d446 3
d804 6
a809 1
  my $file = $sparemint_dir . "/AUTHORS.html";
d818 3
a866 4
    print "removing $html_dir/*.html\n" if $verbose;
    `rm -f $html_dir/*.html`;
    print "removing $pkg_dir/*.html\n" if $verbose;
    `rm -f $pkg_dir/*.html`;
d879 3
d892 3
d905 3
d979 1
a979 1
        <DD><A HREF="$pkg_dir/$name.html">Information</A><BR>
d1111 2
a1112 2
    <A HREF="../arts.html">
      <IMG ALIGN=right SRC="images/spare_small.jpeg" ALT="Sparemint logo">
d1205 3
d1305 3
@


1.6
log
@Put package descriptions into html/packages.
Construct html filenames without version information.
A lot of bugfixes.
@
text
@d20 1
a20 1
# $Id: buildsite.pl,v 1.5 1999/08/14 13:59:24 user Exp user $
d22 5
d48 1
a48 1
$Revision = '$Revision: 1.5 $';
d1110 3
a1112 1
    <IMG ALIGN=right SRC="images/spare_small.gif" ALT="">
@


1.5
log
@Added Sparemint logo to package descriptions.
@
text
@d20 1
a20 1
# $Id: buildsite.pl,v 1.4 1999/08/13 14:31:49 user Exp user $
d22 3
d43 1
a43 1
$Revision = '$Revision: 1.4 $';
d67 1
d207 1
a207 1
  $generated = "Generated automatically " . $generated . " UTC by $prog_name Revision $Version.\n";
d228 1
d248 1
d858 1
d868 2
d917 2
d955 3
a957 1
    
a958 1
      my $new = "";
d960 2
a961 1
        $new = " <EM>NEW THIS WEEK</EM>\n";
d963 2
a964 1
        $new = " <EM>NEW THIS MONTH</EM>\n";
d968 1
a968 1
    print PACKAGES "    <LI>$name $new\n";
d973 1
a973 1
        <DD><A HREF="$name-$version-$release.html">Information</A><BR>
d1096 4
a1099 4
    my $info_html = "$html_dir/$name-$version-$release.html";
    print "creating $html_dir/" . "$name-$version-$release.html\n" if $verbose;
    open INFO, ">$html_dir/$name-$version-$release.html"
      or die "$prog_name: cannot create $html/$name-$version-$release.html: $!";
d1106 1
d1124 1
a1124 1
<LI>Sources: <A HREF="../SRPMS/$sourcerpm">$sourcerpm</A> $fparen_srcsize<BR>
d1130 5
a1134 1
<A HREF="../RPMS/$package">Download</A> ($fpackagesize bytes)
d1138 1
a1138 1
    close INFO or die "$prog_name: cannot close  $html/$name-$version-$release.html: $!";
d1145 5
a1149 2
  print PACKAGES <<EOF;
  </UL>
d1153 12
d1235 1
a1235 1
      $new = " <EM>NEW THIS WEEK</EM>\n";
d1237 1
a1237 1
      $new = " <EM>NEW THIS MONTH</EM>\n";
d1244 1
a1244 1
        <DD><A HREF="$name-$version-$release.html">
d1246 1
a1246 1
            <A HREF="../RPMS/$rpms{$package}{arch}/$package">Download</A>
d1255 4
d1403 10
a1412 2
  
  print TODO_HTML "<HR>\n$generated\n";
@


1.4
log
@Calculate number of orphaned and waiting packages correctly
and display a descriptive text if it is zero.
Don't show total sizes in package list sorted by group (spurious bug).
Don't print a semi-colon after new maintainer.
@
text
@d20 1
a20 1
# $Id: buildsite.pl,v 1.3 1999/08/11 20:54:24 user Exp user $
d22 6
d40 1
a40 1
$Revision = '$Revision: 1.3 $';
d1091 1
@


1.3
log
@Various improvements and changes.
@
text
@d20 5
a24 2
# $Id: buildsite.pl,v 1.2 1999/08/11 11:40:01 user Exp $
# $Log$
d34 1
a34 1
$Revision = '$Revision: 1.2 $';
d681 1
a681 1
    next PACKAGE if (!($package and $status));
d1100 1
a1100 1
$new_maintainer;
d1188 1
a1188 1
      print PACKAGES "    <H2>$last</H2>\n    <A NAME=$last>$last</A>\n";
a1214 3
    $total_size bytes in $number_of_packages binary packages.  Installation
    size totals to $total_installed_size bytes.
    <HR>
d1234 2
d1256 1
a1256 1
    taking over maintainance for this package.
d1273 1
a1273 1
taking over maintainance for this package.
d1279 1
d1289 15
a1304 2
    </UL>
    
d1311 1
a1311 1
      taking over maintainance for this package.
d1325 1
a1325 1
taking over maintainance for this package.
d1331 1
d1342 18
a1359 1
  print TODO_HTML "    </UL>\n<HR>\n$generated\n";
@


1.2
log
@Removed filter.
@
text
@d20 2
a21 1
# $Id: buildsite.pl,v 1.1 1999/08/10 23:40:23 user Exp user $
d27 6
a32 1
$Revision = '$Revision$';
d57 2
d62 3
d77 1
a77 1
# 	Package|Status|Maintainer
d85 1
a85 1
#	    The package is already assigned to a maintainer but
d87 2
a88 1
#	o - The package is ready but currently orphaned.  If you
d91 1
a91 1
#       r - Released
d94 4
d126 1
d128 1
d140 4
d148 5
d174 1
a174 1
$0 (Sparemint) $Version
d194 1
a194 1
  $generated = "Generated automatically " . $generated . " UTC by $prog_name $Version.\n";
d217 2
d236 2
d291 1
a291 1
      close HANDLE or die "$prog_name: error: cannot close $file: $!";
d325 5
d371 16
d476 1
a476 1
      die "$prog_name: error: $rpm -qp --provides $fullname failed: $!";
d512 1
a512 1
    $conflics = "";
d574 16
d601 6
d652 1
a652 1
    print STDERR "$prog_name: cannot parse email address \`$_' in $filename";
d676 4
a679 1
    my ($package, $status, $tag) = split /\|/;
d682 16
d700 2
a701 2
    if (!$authors{$tag}) {
      print STDERR "$prog_name: $package_list: $lineno: warning: unknown author tag \`$tag'\n";
d704 10
d716 1
a716 1
  close AUTHORS;
d722 1
a722 1
  print "writing $file\n" if $verbose;
d736 1
a736 1
  print "writing $file\n" if $verbose;
d797 1
a797 1
  print "writing $file\n" if $verbose;
d834 4
d840 13
a852 4
  my $file = $html_dir . "/packages.html";
  
  print "removing $html_dir/*.html\n" if $verbose;
  `rm -f $html_dir/*.html`;
d854 1
a854 1
  print "writing $file\n" if $verbose;
d857 24
a880 2
  
  print PACKAGES <<EOF;
d886 7
a892 2
   
    <P>
d896 4
a899 1
  foreach my $package (sort { uc ($a) cmp uc ($b) } keys %rpms) {
d908 1
d914 4
a917 1
  foreach my $package (sort { uc ($a) cmp uc ($b) } keys %rpms) {
d920 1
d933 1
a933 1
      print PACKAGES "    <A NAME=$last></A>\n";
d936 10
a945 1
    print PACKAGES "    <LI>$name\n\n";
d950 1
a950 2
        <DD><A HREF="$name-$version-$release.html">
          Information</A><BR>
d956 8
d968 3
a970 1
      print STDERR "$prog_name: warning: package $name not listed in $package_list\n";
d972 3
a974 1
      print STDERR "$prog_name: warning: package $package is listed multiple times in $packages_list\n";
d981 3
a983 1
        print STDERR "$prog_name: warning: $package_list says that $maintainer maintains $package, not $rpms{$package}{packager}\n";
d993 1
a993 1
        $fparen_srcsize = " (" . $fparen_srcsize . ")";
d995 3
a997 1
        print STDERR "$prog_name: warning: no source rpm for $package\n";
d1003 1
a1003 1
    if ($rpms{$package}{changelogname}) {
d1046 25
d1088 1
d1097 1
d1099 1
a1099 1
<LI>Sources: <A HREF="../SRPMS/$source_rpm">$sourcerpm</A> $fparen_srcsize<BR>
d1112 3
a1114 2
  print PACKAGES "<HR>\n$generated\n";
  print PACKAGES "    </UL>";
d1116 9
d1126 13
d1141 190
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
# $Id$
d26 1
a26 1
$Version = "0.1";
d295 1
a295 1
  my @@files = grep { /^[^.c-z]/ && -f "$srpms_dir/$_" } readdir(DIR);
d374 1
a374 1
  my @@files = grep { /^[^.c-z]/ && -f "$dir/$_" } readdir(DIR);
@
